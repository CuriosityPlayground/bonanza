package analysis

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/buildbarn/bonanza/pkg/evaluation"
	"github.com/buildbarn/bonanza/pkg/label"
	model_core "github.com/buildbarn/bonanza/pkg/model/core"
	model_analysis_pb "github.com/buildbarn/bonanza/pkg/proto/model/analysis"
	"github.com/buildbarn/bonanza/pkg/storage/dag"
)

func (c *baseComputer[TReference, TMetadata]) ComputeCanonicalRepoNameValue(ctx context.Context, key *model_analysis_pb.CanonicalRepoName_Key, e CanonicalRepoNameEnvironment[TReference, TMetadata]) (PatchedCanonicalRepoNameValue, error) {
	fromCanonicalRepo, err := label.NewCanonicalRepo(key.FromCanonicalRepo)
	if err != nil {
		return PatchedCanonicalRepoNameValue{}, fmt.Errorf("invalid canonical repo: %w", err)
	}

	toApparentRepo := key.ToApparentRepo
	if moduleExtension, _, ok := fromCanonicalRepo.GetModuleExtension(); ok {
		// Repos that were generated by the same module
		// extension are capable of accessing each other using
		// their short names.
		moduleExtensionRepoNamesValue := e.GetModuleExtensionRepoNamesValue(&model_analysis_pb.ModuleExtensionRepoNames_Key{
			ModuleExtension: moduleExtension.String(),
		})
		if !moduleExtensionRepoNamesValue.IsSet() {
			return PatchedCanonicalRepoNameValue{}, evaluation.ErrMissingDependency
		}
		repoNames := moduleExtensionRepoNamesValue.Message.RepoNames
		if _, ok := sort.Find(
			len(repoNames),
			func(i int) int { return strings.Compare(toApparentRepo, repoNames[i]) },
		); ok {
			apparentRepo, err := label.NewApparentRepo(toApparentRepo)
			if err != nil {
				return PatchedCanonicalRepoNameValue{}, fmt.Errorf("invalid apparent repo: %w", err)
			}
			return model_core.NewSimplePatchedMessage[dag.ObjectContentsWalker](&model_analysis_pb.CanonicalRepoName_Value{
				ToCanonicalRepo: moduleExtension.GetCanonicalRepoWithModuleExtension(apparentRepo).String(),
			}), nil
		}
	}

	// Consider modules and repos declared in MODULE.bazel.
	moduleRepoMappingValue := e.GetModuleRepoMappingValue(&model_analysis_pb.ModuleRepoMapping_Key{
		ModuleInstance: fromCanonicalRepo.GetModuleInstance().String(),
	})
	if !moduleRepoMappingValue.IsSet() {
		return PatchedCanonicalRepoNameValue{}, evaluation.ErrMissingDependency
	}
	mappings := moduleRepoMappingValue.Message.Mappings
	if mappingIndex, ok := sort.Find(
		len(mappings),
		func(i int) int { return strings.Compare(toApparentRepo, mappings[i].FromApparentRepo) },
	); ok {
		return model_core.NewSimplePatchedMessage[dag.ObjectContentsWalker](&model_analysis_pb.CanonicalRepoName_Value{
			ToCanonicalRepo: mappings[mappingIndex].ToCanonicalRepo,
		}), nil
	}

	// Unknown repo.
	return model_core.NewSimplePatchedMessage[dag.ObjectContentsWalker](&model_analysis_pb.CanonicalRepoName_Value{}), nil
}
